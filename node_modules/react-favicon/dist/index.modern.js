function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var React = require('react');

var PropTypes = require('prop-types');

var faviconSize = 16;
var linkEl;

function drawIcon(_ref) {
  var src = _ref.url,
      num = _ref.alertCount,
      cb = _ref.callback,
      renderOverlay = _ref.renderOverlay;
  var img = document.createElement('img');
  img.crossOrigin = 'Anonymous';

  img.onload = function () {
    var canvas = document.createElement('canvas');
    canvas.width = faviconSize;
    canvas.height = faviconSize;
    var context = canvas.getContext('2d');
    context.clearRect(0, 0, img.width, img.height);
    context.drawImage(img, 0, 0, canvas.width, canvas.height);

    if (num) {
      var top = canvas.height - 9;
      var left = canvas.width - 7 - 1;
      var bottom = faviconSize;
      var right = faviconSize;
      var radius = 2;
      context.fillStyle = '#F03D25';
      context.strokeStyle = '#F03D25';
      context.lineWidth = 1;
      context.beginPath();
      context.moveTo(left + radius, top);
      context.quadraticCurveTo(left, top, left, top + radius);
      context.lineTo(left, bottom - radius);
      context.quadraticCurveTo(left, bottom, left + radius, bottom);
      context.lineTo(right - radius, bottom);
      context.quadraticCurveTo(right, bottom, right, bottom - radius);
      context.lineTo(right, top + radius);
      context.quadraticCurveTo(right, top, right - radius, top);
      context.closePath();
      context.fill();
      context.font = 'bold 10px arial';
      context.fillStyle = '#FFF';
      context.textAlign = 'right';
      context.textBaseline = 'top';
      context.fillText(num, 15, 6);
    }

    if (renderOverlay) {
      renderOverlay(canvas, context);
    }

    cb(null, context.canvas.toDataURL());
  };

  img.src = src;
}

var Favicon = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Favicon, _React$Component);

  function Favicon() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      animationIndex: 0,
      animationLoop: null,
      animationRunning: false
    };
    return _this;
  }

  Favicon.getActiveInstance = function getActiveInstance() {
    return Favicon.mountedInstances[Favicon.mountedInstances.length - 1];
  };

  Favicon.draw = function draw() {
    if (typeof document === 'undefined') return;
    var activeInstance = Favicon.getActiveInstance();

    if (typeof linkEl === 'undefined') {
      var head = document.getElementsByTagName('head')[0];
      linkEl = document.createElement('link');
      linkEl.type = 'image/x-icon';
      linkEl.rel = 'icon';
      var links = head.getElementsByTagName('link');

      for (var i = links.length; --i >= 0;) {
        if (/\bicon\b/i.test(links[i].getAttribute('rel')) && !activeInstance.props.keepIconLink(links[i])) {
          head.removeChild(links[i]);
        }
      }

      head.appendChild(linkEl);
    }

    var currentUrl;

    if (activeInstance.props.url instanceof Array) {
      currentUrl = activeInstance.props.url[activeInstance.state.animationIndex];
    } else {
      currentUrl = activeInstance.props.url;
    }

    if (activeInstance.props.alertCount || activeInstance.props.renderOverlay) {
      drawIcon({
        alertCount: activeInstance.props.alertCount,
        callback: function callback(_, url) {
          linkEl.href = url;
        },
        renderOverlay: activeInstance.props.renderOverlay,
        url: currentUrl
      });
    } else {
      linkEl.href = currentUrl;
    }
  };

  Favicon.update = function update() {
    if (typeof document === 'undefined') return;
    var activeInstance = Favicon.getActiveInstance();
    var isAnimated = activeInstance.props.url instanceof Array && activeInstance.props.animated;
    var intervalId = null;
    clearInterval(activeInstance.state.animationLoop);

    if (isAnimated) {
      var animateFavicon = function animateFavicon() {
        var nextAnimationIndex = (activeInstance.state.animationIndex + 1) % activeInstance.props.url.length;
        Favicon.draw();
        activeInstance.setState({
          animationIndex: nextAnimationIndex
        });
      };

      intervalId = setInterval(animateFavicon, activeInstance.props.animationDelay);
      animateFavicon();
    } else {
      Favicon.draw();
    }

    activeInstance.setState({
      animationLoop: intervalId
    });
  };

  var _proto = Favicon.prototype;

  _proto.componentDidMount = function componentDidMount() {
    Favicon.mountedInstances.push(this);
    Favicon.update();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var activeInstance = Favicon.getActiveInstance();
    clearInterval(activeInstance.state.animationLoop);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.url === this.props.url && prevProps.animated === this.props.animated && prevProps.alertCount === this.props.alertCount && prevProps.renderOverlay === this.props.renderOverlay && prevProps.keepIconLink === this.props.keepIconLink) return;
    Favicon.update();
  };

  _proto.render = function render() {
    return null;
  };

  return Favicon;
}(React.Component);

Favicon.displayName = 'Favicon';
Favicon.mountedInstances = [];
Favicon.defaultProps = {
  alertCount: null,
  animated: true,
  animationDelay: 500,
  keepIconLink: function keepIconLink() {
    return false;
  },
  renderOverlay: null,
  url: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]).isRequired
};
Favicon.propTypes = {
  alertCount: PropTypes.number,
  animated: PropTypes.bool,
  animationDelay: PropTypes.number,
  keepIconLink: PropTypes.func,
  renderOverlay: PropTypes.func
};
module.exports = Favicon;
//# sourceMappingURL=index.modern.js.map
